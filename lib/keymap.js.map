{"version":3,"sources":["../src/keymap.js"],"names":["module","exports","CodeMirror","defaultKeymap","_defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","enterVimMode","cm","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","state","vim","detachVimMap","next","keyMap","rmClass","getWrapperElement","attach","attachVimMap","prev","addClass","defineOption","val","getOption","Init","test","cmKey","key","undefined","vimKey","cmKeyToVimKey","cmd","findKey","modifiers","specialKeys","Enter","Backspace","Delete","Insert","charAt","pieces","split","lastPiece","length","hasCharacter","i","piece","isUpperCase","toLowerCase","join","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","ch","bigWordCharTest","makeKeyRange","start","size","push","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","line","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","inArray","arr","options","defaultValue","aliases","callback","Error","value","cfg","option","scope","local","createCircularJumpList","pointer","head","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","trashMark","clear","setBookmark","markPos","find","cursorEqual","move","offset","mark","inc","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","prototype","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","bottom","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","marks","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","increment","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","match","exec","substring","index","handleKeyInsertMode","keyBuffer","debug","keysAreChars","commandDispatcher","matchCommand","slice","thisMatch","window","clearTimeout","setTimeout","selections","listSelections","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","pushRepeatDigit","operation","curOp","isVimOp","processCommand","e","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","_mapCommand","defineRegister","prefixRepeat","motionRepeat","n","getRepeat","repeat","parseInt","reason","Register","text","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","registers","unnamedRegister","isValidRegister","reg","clipboard","require","writeText","shiftNumericRegisters_","append","historyBuffer","iterator","initialPrefix","nextMatch","up","dir","element","j","pushInput","splice","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","ignoreCase","smartCase","updateSearchQuery","showConfirm","onPromptClose","scrollTo","left","top","logSearchQuery","onPromptKeyUp","close","keyName","target","selectionEnd","selectionStart","Math","min","parsedQuery","scrollIntoView","findNext","clearSearchHighlight","onPromptKeyDown","e_stop","focus","shift","showPrompt","onClose","desc","searchPromptDesc","onKeyUp","onKeyDown","word","expandWordUnderCursor","isKeyword","getLine","end","escapeRegex","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","anchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","ranges","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","range","floor","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","getTokenTypeAt","matched","findMatchingBracket","to","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","inVisualBlock","getRange","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","getSelection","replacement","replaceSelections","indent","startLine","endLine","indentLine","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","classList","remove","max","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","re","numberStr","token","number","from","repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","getOffset","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","curHead","primIndex","getIndex","wasClipped","base","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","width","setSelection","updateFakeCursor","headOffset","anchorOffset","right","getHead","moveHead","selection","lines","firstNonWS","search","_forward","noSymbol","wordStart","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","bracketRegexp","openSym","curChar","scanForBracket","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","dialog","template","shortText","selectValueOnOpen","prompt","splitBySlash","argString","slashes","findUnescapedSlashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","RegExp","regexPart","forceIgnoreCase","flagsPart","regexp","openNotification","duration","alert","makePrompt","raw","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","skipToEnd","backUp","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","history","doc","done","event","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","result","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","mapping","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","reverse","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","substr","err","lineStart","radix","numPart","textPart","matchPart","compareFn","a","b","anum","bnum","comparePatternFn","textOld","global","matchedLines","content","nextCommand","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","detach","insertModeChangeRegister","lastChange","selLength","logInsertModeChange","extra","fallthrough","imc","repeatInsertModeChanges","changeObj","maybeReset","handleExternalSelection","markText","className","somethingSelected","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding"],"mappings":"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","file":"keymap.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nmodule.exports = function (CodeMirror) {\n  var defaultKeymap = [\n  ]\n  var _defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal' },\n    //\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar: true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context: 'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context: 'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ]\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ]\n\n  var Pos = CodeMirror.Pos\n\n  var Vim = function () {\n    function enterVimMode (cm) {\n      cm.setOption('disableInput', true)\n      cm.setOption('showCursorWhenSelecting', false)\n      CodeMirror.signal(cm, 'vim-mode-change', {mode: 'normal'})\n      cm.on('cursorActivity', onCursorActivity)\n      maybeInitVimState(cm)\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm))\n    }\n\n    function leaveVimMode (cm) {\n      cm.setOption('disableInput', false)\n      cm.off('cursorActivity', onCursorActivity)\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm))\n      cm.state.vim = null\n    }\n\n    function detachVimMap (cm, next) {\n      if (this == CodeMirror.keyMap.vim) { CodeMirror.rmClass(cm.getWrapperElement(), 'cm-fat-cursor') }\n\n      if (!next || next.attach != attachVimMap) { leaveVimMode(cm) }\n    }\n    function attachVimMap (cm, prev) {\n      if (this == CodeMirror.keyMap.vim) { CodeMirror.addClass(cm.getWrapperElement(), 'cm-fat-cursor') }\n\n      if (!prev || prev.attach != attachVimMap) { enterVimMode(cm) }\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n      if (val && cm.getOption('keyMap') != 'vim') { cm.setOption('keyMap', 'vim') } else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption('keyMap'))) { cm.setOption('keyMap', 'default') }\n    })\n\n    function cmKey (key, cm) {\n      if (!cm) { return undefined }\n      if (this[key]) { return this[key] }\n      var vimKey = cmKeyToVimKey(key)\n      if (!vimKey) {\n        return false\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey)\n      if (typeof cmd === 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey)\n      }\n      return cmd\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'}\n    var specialKeys = {Enter: 'CR', Backspace: 'BS', Delete: 'Del', Insert: 'Ins'}\n    function cmKeyToVimKey (key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1)\n      }\n      var pieces = key.split(/-(?!$)/)\n      var lastPiece = pieces[pieces.length - 1]\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false\n      }\n      var hasCharacter = false\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i]\n        if (piece in modifiers) { pieces[i] = modifiers[piece] } else { hasCharacter = true }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece] }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase()\n      }\n      return '<' + pieces.join('-') + '>'\n    }\n\n    function getOnPasteFn (cm) {\n      var vim = cm.state.vim\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1))\n            actions.enterInsertMode(cm, {}, vim)\n          }\n        }\n      }\n      return vim.onPasteFn\n    }\n\n    var numberRegex = /[\\d]/\n    var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n        return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch)\n      }], bigWordCharTest = [function (ch) {\n        return /\\S/.test(ch)\n      }]\n    function makeKeyRange (start, size) {\n      var keys = []\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i))\n      }\n      return keys\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26)\n    var lowerCaseAlphabet = makeKeyRange(97, 26)\n    var numbers = makeKeyRange(48, 10)\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>'])\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/'])\n\n    function isLine (cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine()\n    }\n    function isLowerCase (k) {\n      return (/^[a-z]$/).test(k)\n    }\n    function isMatchableSymbol (k) {\n      return '()[]{}'.indexOf(k) != -1\n    }\n    function isNumber (k) {\n      return numberRegex.test(k)\n    }\n    function isUpperCase (k) {\n      return (/^[A-Z]$/).test(k)\n    }\n    function isWhiteSpaceString (k) {\n      return (/^\\s*$/).test(k)\n    }\n    function inArray (val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true\n        }\n      }\n      return false\n    }\n\n    var options = {}\n    function defineOption (name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided')\n      }\n      if (!type) { type = 'string' }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      }\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name]\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue)\n      }\n    }\n\n    function setOption (name, value, cm, cfg) {\n      var option = options[name]\n      cfg = cfg || {}\n      var scope = cfg.scope\n      if (!option) {\n        return new Error('Unknown option: ' + name)\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value)\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined)\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm)\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value}\n        }\n      }\n    }\n\n    function getOption (name, cm, cfg) {\n      var option = options[name]\n      cfg = cfg || {}\n      var scope = cfg.scope\n      if (!option) {\n        return new Error('Unknown option: ' + name)\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm)\n        if (scope !== 'global' && local !== undefined) {\n          return local\n        }\n        if (scope !== 'local') {\n          return option.callback()\n        }\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name])\n        return (local || (scope !== 'local') && option || {}).value\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode')\n        return mode == 'null' ? '' : mode\n      } else {\n        var mode = name == '' ? 'null' : name\n        cm.setOption('mode', mode)\n      }\n    })\n\n    var createCircularJumpList = function () {\n      var size = 100\n      var pointer = -1\n      var head = 0\n      var tail = 0\n      var buffer = new Array(size)\n      function add (cm, oldCur, newCur) {\n        var current = pointer % size\n        var curMark = buffer[current]\n        function useNextSlot (cursor) {\n          var next = ++pointer % size\n          var trashMark = buffer[next]\n          if (trashMark) {\n            trashMark.clear()\n          }\n          buffer[next] = cm.setBookmark(cursor)\n        }\n        if (curMark) {\n          var markPos = curMark.find()\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur)\n          }\n        } else {\n          useNextSlot(oldCur)\n        }\n        useNextSlot(newCur)\n        head = pointer\n        tail = pointer - size + 1\n        if (tail < 0) {\n          tail = 0\n        }\n      }\n      function move (cm, offset) {\n        pointer += offset\n        if (pointer > head) {\n          pointer = head\n        } else if (pointer < tail) {\n          pointer = tail\n        }\n        var mark = buffer[(size + pointer) % size]\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1\n          var newCur\n          var oldCur = cm.getCursor()\n          do {\n            pointer += inc\n            mark = buffer[(size + pointer) % size]\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break\n            }\n          } while (pointer < head && pointer > tail)\n        }\n        return mark\n      }\n      return {\n        cachedCursor: undefined, // used for # and * jumps\n        add: add,\n        move: move\n      }\n    }\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function (c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        }\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      }\n    }\n\n    function MacroModeState () {\n      this.latestRegister = undefined\n      this.isPlaying = false\n      this.isRecording = false\n      this.replaySearchQueries = []\n      this.onRecordingDone = undefined\n      this.lastInsertModeChanges = createInsertModeChanges()\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function () {\n        var macroModeState = vimGlobalState.macroModeState\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone() // close dialog\n        }\n        macroModeState.onRecordingDone = undefined\n        macroModeState.isRecording = false\n      },\n      enterMacroRecordMode: function (cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName)\n        if (register) {\n          register.clear()\n          this.latestRegister = registerName\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)[' + registerName + ']', null, {bottom: true})\n          }\n          this.isRecording = true\n        }\n      }\n    }\n\n    function maybeInitVimState (cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        }\n      }\n      return cm.state.vim\n    }\n    var vimGlobalState\n    function resetVimGlobalState () {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState(),\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment: 0, forward: true, selectedCharacter: ''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController: new HistoryController()\n      }\n      for (var optionName in options) {\n        var option = options[optionName]\n        option.value = option.defaultValue\n      }\n    }\n\n    var lastInsertModeKeyTimer\n    var vimApi = {\n      buildKeyMap: function () {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function () {\n        return vimGlobalState.registerController\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function () {\n        return vimGlobalState\n      },\n\n      // Testing hook.\n      maybeInitVimState: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function (lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx)\n      },\n      unmap: function (lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx)\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function (name, prefix, func) {\n        if (!prefix) {\n          prefix = name\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered')\n        }\n        exCommands[name] = func\n        exCommandDispatcher.commandMap_[prefix] = {name: name, shortName: prefix, type: 'api'}\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin)\n        if (typeof command === 'function') {\n          return command()\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function (cm, key, origin) {\n        var vim = maybeInitVimState(cm)\n        function handleMacroRecording () {\n          var macroModeState = vimGlobalState.macroModeState\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode()\n              clearInputState(cm)\n              return true\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key)\n            }\n          }\n        }\n        function handleEsc () {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm)\n            if (vim.visualMode) {\n              exitVisualMode(cm)\n            } else if (vim.insertMode) {\n              exitInsertMode(cm)\n            }\n            return true\n          }\n        }\n        function doKeyToKey (keys) {\n          // TODO: prevent infinite recursion.\n          var match\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys)\n            key = match[0]\n            keys = keys.substring(match.index + key.length)\n            CodeMirror.Vim.handleKey(cm, key, 'mapping')\n          }\n        }\n\n        function handleKeyInsertMode () {\n          if (handleEsc()) { return true }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key\n          debug('keyBuffer:', keys)\n          var keysAreChars = key.length == 1\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert')\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type !== 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1)\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert')\n            if (thisMatch.type !== 'none') {\n              match = thisMatch\n            }\n          }\n          if (match.type === 'none') {\n            clearInputState(cm)\n            return false\n          } else if (match.type === 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer) }\n            lastInsertModeKeyTimer = window.setTimeout(() => {\n              if (vim.insertMode && vim.inputState.keyBuffer) {\n                clearInputState(cm)\n              }\n            }, getOption('insertModeEscKeysTimeout'))\n            return !keysAreChars\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer) }\n          if (keysAreChars) {\n            var selections = cm.listSelections()\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input')\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop()\n          }\n          clearInputState(cm)\n          return match.command\n        }\n\n        function handleKeyNonInsertMode () {\n          if (handleMacroRecording() || handleEsc()) { return true };\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key\n          if (/^[1-9]\\d*$/.test(keys)) { return true }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys)\n          if (!keysMatcher) { clearInputState(cm); return false }\n          var context = vim.visualMode ? 'visual' : 'normal'\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context)\n          if (match.type === 'none') {\n            clearInputState(cm)\n            return false\n          } else if (match.type === 'partial') {\n            return true\n          }\n\n          vim.inputState.keyBuffer = ''\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys)\n          if (keysMatcher[1] && keysMatcher[1] !== '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1])\n          }\n          return match.command\n        }\n\n        var command\n        if (vim.insertMode) {\n          command = handleKeyInsertMode()\n        } else {\n          command = handleKeyNonInsertMode()\n        }\n\n        debug('keyBuffer::::', command, vim.inputState.keyBuffer, vim.inputState.operator, vim.inputState.operatorArgs)\n\n        if (command === false) {\n          return undefined\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function () { return true }\n        } else {\n          return function () {\n            return cm.operation(function () {\n              cm.curOp.isVimOp = true\n              try {\n                if (command.type === 'keyToKey') {\n                  doKeyToKey(command.toKeys)\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command)\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined\n                maybeInitVimState(cm)\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e)\n                }\n                throw e\n              }\n              return true\n            })\n          }\n        }\n      },\n      handleEx: function (cm, input) {\n        exCommandDispatcher.processCommand(cm, input)\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode,\n      clearInputState: clearInputState,\n\n      cmKeyToVimKey: cmKeyToVimKey\n    }\n\n    // Represents the current input state.\n    function InputState () {\n      this.prefixRepeat = []\n      this.motionRepeat = []\n\n      this.operator = null\n      this.operatorArgs = null\n      this.motion = null\n      this.motionArgs = null\n      this.keyBuffer = [] // For matching multi-key commands.\n      this.registerName = null // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function (n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n)\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n)\n      }\n    }\n    InputState.prototype.getRepeat = function () {\n      var repeat = 0\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10)\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10)\n        }\n      }\n      return repeat\n    }\n\n    function clearInputState (cm, reason) {\n      cm.state.vim.inputState = new InputState()\n      CodeMirror.signal(cm, 'vim-command-done', reason)\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register (text, linewise, blockwise) {\n      this.clear()\n      this.keyBuffer = [text || '']\n      this.insertModeChanges = []\n      this.searchQueries = []\n      this.linewise = !!linewise\n      this.blockwise = !!blockwise\n    }\n    Register.prototype = {\n      setText: function (text, linewise, blockwise) {\n        this.keyBuffer = [text || '']\n        this.linewise = !!linewise\n        this.blockwise = !!blockwise\n      },\n      pushText: function (text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n')\n          }\n          this.linewise = true\n        }\n        this.keyBuffer.push(text)\n      },\n      pushInsertModeChanges: function (changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes))\n      },\n      pushSearchQuery: function (query) {\n        this.searchQueries.push(query)\n      },\n      clear: function () {\n        this.keyBuffer = []\n        this.insertModeChanges = []\n        this.searchQueries = []\n        this.linewise = false\n      },\n      toString: function () {\n        return this.keyBuffer.join('')\n      }\n    }\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister (name, register) {\n      var registers = vimGlobalState.registerController.registers\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character')\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name)\n      }\n      registers[name] = register\n      validRegisters.push(name)\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController (registers) {\n      this.registers = registers\n      this.unnamedRegister = registers['\"'] = new Register()\n      registers['.'] = new Register()\n      registers[':'] = new Register()\n      registers['/'] = new Register()\n    }\n    RegisterController.prototype = {\n      pushText: function (registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n          text += '\\n'\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName)\n            ? this.getRegister(registerName) : null\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              const reg = new Register(text, linewise, blockwise)\n              debug('yanked:', reg)\n              this.registers['0'] = reg\n              const { clipboard } = require('electron')\n              clipboard.writeText(reg.keyBuffer[0])\n              break\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise)\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_()\n                this.registers['1'] = new Register(text, linewise)\n              }\n              break\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise)\n          return\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName)\n        if (append) {\n          register.pushText(text, linewise)\n        } else {\n          register.setText(text, linewise, blockwise)\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise)\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function (name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister\n        }\n        name = name.toLowerCase()\n        if (!this.registers[name]) {\n          this.registers[name] = new Register()\n        }\n        return this.registers[name]\n      },\n      isValidRegister: function (name) {\n        return name && inArray(name, validRegisters)\n      },\n      shiftNumericRegisters_: function () {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1))\n        }\n      }\n    }\n    function HistoryController () {\n      this.historyBuffer = []\n      this.iterator = 0\n      this.initialPrefix = null\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer\n        var dir = up ? -1 : 1\n        if (this.initialPrefix === null) this.initialPrefix = input\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n          var element = historyBuffer[i]\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i\n              return element\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length\n          return this.initialPrefix\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0) return input\n      },\n      pushInput: function (input) {\n        var index = this.historyBuffer.indexOf(input)\n        if (index > -1) this.historyBuffer.splice(index, 1)\n        if (input.length) this.historyBuffer.push(input)\n      },\n      reset: function () {\n        this.initialPrefix = null\n        this.iterator = this.historyBuffer.length\n      }\n    }\n    var commandDispatcher = {\n      matchCommand: function (keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState)\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'}\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'}\n        }\n\n        var bestMatch\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i]\n          if (!bestMatch) {\n            bestMatch = match\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys)\n          if (!character) return {type: 'none'}\n          inputState.selectedCharacter = character\n        }\n        return {type: 'full', command: bestMatch}\n      },\n      processCommand: function (cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command)\n            break\n          case 'operator':\n            this.processOperator(cm, vim, command)\n            break\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command)\n            break\n          case 'action':\n            this.processAction(cm, vim, command)\n            break\n          case 'search':\n            this.processSearch(cm, vim, command)\n            break\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command)\n            break\n          default:\n            break\n        }\n      },\n      processMotion: function (cm, vim, command) {\n        vim.inputState.motion = command.motion\n        vim.inputState.motionArgs = copyArgs(command.motionArgs)\n        this.evalInput(cm, vim)\n      },\n      processOperator: function (cm, vim, command) {\n        var inputState = vim.inputState\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine'\n            inputState.motionArgs = { linewise: true }\n            this.evalInput(cm, vim)\n            return\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm)\n          }\n        }\n        inputState.operator = command.operator\n        inputState.operatorArgs = copyArgs(command.operatorArgs)\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim)\n        }\n      },\n      processOperatorMotion: function (cm, vim, command) {\n        var visualMode = vim.visualMode\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs)\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true\n          }\n        }\n        this.processOperator(cm, vim, command)\n        if (!visualMode) {\n          this.processMotion(cm, vim, command)\n        }\n      },\n      processAction: function (cm, vim, command) {\n        var inputState = vim.inputState\n        var repeat = inputState.getRepeat()\n        var repeatIsExplicit = !!repeat\n        var actionArgs = copyArgs(command.actionArgs) || {}\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command)\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command)\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim)\n        }\n        actionArgs.repeat = repeat || 1\n        actionArgs.repeatIsExplicit = repeatIsExplicit\n        actionArgs.registerName = inputState.registerName\n        clearInputState(cm)\n        vim.lastMotion = null\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command)\n        }\n        actions[command.action](cm, actionArgs, vim)\n      },\n      processSearch: function (cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return\n        }\n        var forward = command.searchArgs.forward\n        var wholeWordOnly = command.searchArgs.wholeWordOnly\n        getSearchState(cm).setReversed(!forward)\n        var promptPrefix = (forward) ? '/' : '?'\n        var originalQuery = getSearchState(cm).getQuery()\n        var originalScrollPos = cm.getScrollInfo()\n        function handleQuery (query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query)\n          vimGlobalState.searchHistoryController.reset()\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase)\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query)\n            clearInputState(cm)\n            return\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          })\n        }\n        function onPromptClose (query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top)\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */)\n          var macroModeState = vimGlobalState.macroModeState\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query)\n          }\n        }\n        function onPromptKeyUp (e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up'\n            offset = e.target ? e.target.selectionEnd : 0\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || ''\n            close(query)\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length)\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') { vimGlobalState.searchHistoryController.reset() }\n          }\n          var parsedQuery\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */)\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30)\n          } else {\n            clearSearchHighlight(cm)\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top)\n          }\n        }\n        function onPromptKeyDown (e, query, close) {\n          var keyName = CodeMirror.keyName(e)\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query)\n            vimGlobalState.searchHistoryController.reset()\n            updateSearchQuery(cm, originalQuery)\n            clearSearchHighlight(cm)\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top)\n            CodeMirror.e_stop(e)\n            clearInputState(cm)\n            close()\n            cm.focus()\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e)\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e)\n            close('')\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift()\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */)\n            } else {\n              showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: searchPromptDesc,\n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n              })\n            }\n            break\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */)\n            var isKeyword = true\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */)\n              isKeyword = false\n            }\n            if (!word) {\n              return\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch)\n            if (isKeyword && wholeWordOnly) {\n              query = '\\\\b' + query + '\\\\b'\n            } else {\n              query = escapeRegex(query)\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor()\n            cm.setCursor(word.start)\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */)\n            break\n        }\n      },\n      processEx: function (cm, vim, command) {\n        function onPromptClose (input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input)\n          vimGlobalState.exCommandHistoryController.reset()\n          exCommandDispatcher.processCommand(cm, input)\n        }\n        function onPromptKeyDown (e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset\n          if (keyName === 'Esc' || keyName === 'Ctrl-C' || keyName === 'Ctrl-[' ||\n              (keyName === 'Backspace' && input === '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input)\n            vimGlobalState.exCommandHistoryController.reset()\n            CodeMirror.e_stop(e)\n            clearInputState(cm)\n            close()\n            cm.focus()\n          }\n          if (keyName === 'Up' || keyName === 'Down') {\n            CodeMirror.e_stop(e)\n            up = keyName === 'Up'\n            offset = e.target ? e.target.selectionEnd : 0\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || ''\n            close(input)\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length)\n          } else if (keyName === 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e)\n            close('')\n          } else {\n            if (keyName !== 'Left' && keyName !== 'Right' && keyName !== 'Ctrl' && keyName !== 'Alt' && keyName !== 'Shift') {\n              vimGlobalState.exCommandHistoryController.reset()\n            }\n          }\n        }\n        if (command.type === 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input)\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose,\n              prefix: ':',\n              value: '\\'<,\\'>',\n              onKeyDown: onPromptKeyDown})\n          } else {\n            showPrompt(cm, { onClose: onPromptClose,\n              prefix: ':',\n              onKeyDown: onPromptKeyDown})\n          }\n        }\n      },\n      evalInput: function (cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState\n        var motion = inputState.motion\n        var motionArgs = inputState.motionArgs || {}\n        var operator = inputState.operator\n        var operatorArgs = inputState.operatorArgs || {}\n        var registerName = inputState.registerName\n        var sel = vim.sel\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'))\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'))\n        var oldHead = copyCursor(origHead)\n        var oldAnchor = copyCursor(origAnchor)\n        var newHead, newAnchor\n        var repeat\n        if (operator) {\n          this.recordLastEdit(vim, inputState)\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride\n        } else {\n          repeat = inputState.getRepeat()\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1\n          motionArgs.repeatIsExplicit = false\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter\n        }\n        motionArgs.repeat = repeat\n        clearInputState(cm)\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim)\n          vim.lastMotion = motions[motion]\n          if (!motionResult) {\n            return\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult)\n              delete jumpList.cachedCursor\n            } else {\n              recordJumpPosition(cm, origHead, motionResult)\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0]\n            newHead = motionResult[1]\n          } else {\n            newHead = motionResult\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead)\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock)\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true)\n            }\n            newAnchor = newAnchor || oldAnchor\n            sel.anchor = newAnchor\n            sel.head = newHead\n            updateCmSelection(cm)\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead)\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor)\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead)\n            cm.setCursor(newHead.line, newHead.ch)\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor\n            var lastSel = operatorArgs.lastSel\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line)\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch)\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch)\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset)\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset)\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch)\n            }\n            vim.visualMode = true\n            vim.visualLine = lastSel.visualLine\n            vim.visualBlock = lastSel.visualBlock\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            }\n            updateCmSelection(cm)\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            }\n          }\n          var curStart, curEnd, linewise, mode\n          var cmSel\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor)\n            curEnd = cursorMax(sel.head, sel.anchor)\n            linewise = vim.visualLine || operatorArgs.linewise\n            mode = vim.visualBlock ? 'block'\n                   : linewise ? 'line'\n                   : 'char'\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode)\n            if (linewise) {\n              var ranges = cmSel.ranges\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line)\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0)\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor)\n            curEnd = copyCursor(newHead || oldHead)\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart\n              curStart = curEnd\n              curEnd = tmp\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd)\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd)\n            }\n            mode = 'char'\n            var exclusive = !motionArgs.inclusive || linewise\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive)\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary)\n          vim.lastMotion = null\n          operatorArgs.repeat = repeat // For indent in visual mode.\n          operatorArgs.registerName = registerName\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead)\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null)\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo)\n          }\n        }\n      },\n      recordLastEdit: function (vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState\n        if (macroModeState.isPlaying) { return }\n        vim.lastEditInputState = inputState\n        vim.lastEditActionCommand = actionCommand\n        macroModeState.lastInsertModeChanges.changes = []\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false\n      }\n    }\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)))\n      },\n      moveToMiddleLine: function (cm) {\n        var range = getUserVisibleLines(cm)\n        var line = Math.floor((range.top + range.bottom) * 0.5)\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)))\n      },\n      moveToBottomLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)))\n      },\n      expandToLine: function (_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity)\n      },\n      findNext: function (cm, _head, motionArgs) {\n        var state = getSearchState(cm)\n        var query = state.getQuery()\n        if (!query) {\n          return\n        }\n        var prev = !motionArgs.forward\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev\n        highlightSearchMatches(cm, query)\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat)\n      },\n      goToMark: function (cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter)\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos\n        }\n        return null\n      },\n      moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ]\n        } else {\n          return ([vim.sel.head, vim.sel.anchor])\n        }\n      },\n      jumpToMark: function (cm, head, motionArgs, vim) {\n        var best = head\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue\n            }\n            var mark = vim.marks[key].find()\n            var isWrongDirection = (motionArgs.forward)\n              ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark)\n\n            if (isWrongDirection) {\n              continue\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue\n            }\n\n            var equal = cursorEqual(cursor, best)\n            var between = (motionArgs.forward)\n              ? cursorIsBetween(cursor, mark, best)\n              : cursorIsBetween(best, mark, cursor)\n\n            if (equal || between) {\n              best = mark\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)))\n        }\n        return best\n      },\n      moveByCharacters: function (_cm, head, motionArgs) {\n        var cur = head\n        var repeat = motionArgs.repeat\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat\n        return Pos(cur.line, ch)\n      },\n      moveByLines: function (cm, head, motionArgs, vim) {\n        var cur = head\n        var endCh = cur.ch\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos\n            break\n          default:\n            vim.lastHPos = endCh\n        }\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0)\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat\n        var first = cm.firstLine()\n        var last = cm.lastLine()\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first) {\n          return this.moveToStartOfLine(cm, head, motionArgs, vim)\n        } else if (line > last && cur.line == last) {\n          return this.moveToEol(cm, head, motionArgs, vim)\n        }\n        if (motionArgs.toFirstChar) {\n          endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line))\n          vim.lastHPos = endCh\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh), 'div').left\n        return Pos(line, endCh)\n      },\n      moveByDisplayLines: function (cm, head, motionArgs, vim) {\n        var cur = head\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break\n          default:\n            vim.lastHSPos = cm.charCoords(cur, 'div').left\n        }\n        var repeat = motionArgs.repeat\n        var res = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos)\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div')\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos }\n            var res = cm.coordsChar(goalCoords, 'div')\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div')\n            resCoords.left = vim.lastHSPos\n            res = cm.coordsChar(resCoords, 'div')\n          }\n        }\n        vim.lastHPos = res.ch\n        return res\n      },\n      moveByPage: function (cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head\n        var repeat = motionArgs.repeat\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page')\n      },\n      moveByParagraph: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1\n        return findParagraph(cm, head, motionArgs.repeat, dir)\n      },\n      moveByScroll: function (cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo()\n        var curEnd = null\n        var repeat = motionArgs.repeat\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight())\n        }\n        var orig = cm.charCoords(head, 'local')\n        motionArgs.repeat = repeat\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim)\n        if (!curEnd) {\n          return null\n        }\n        var dest = cm.charCoords(curEnd, 'local')\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top)\n        return curEnd\n      },\n      moveByWords: function (cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord)\n      },\n      moveTillCharacter: function (cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter)\n        var increment = motionArgs.forward ? -1 : 1\n        recordLastCharacterSearch(increment, motionArgs)\n        if (!curEnd) return null\n        curEnd.ch += increment\n        return curEnd\n      },\n      moveToCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat\n        recordLastCharacterSearch(0, motionArgs)\n        debug('moveToCharacter:', motionArgs)\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head\n      },\n      moveToSymbol: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head\n      },\n      moveToColumn: function (cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1\n        vim.lastHSPos = cm.charCoords(head, 'div').left\n        return moveToColumn(cm, repeat)\n      },\n      moveToEol: function (cm, head, motionArgs, vim) {\n        var cur = head\n        vim.lastHPos = Infinity\n        var retval = Pos(cur.line + motionArgs.repeat - 1, Infinity)\n        var end = cm.clipPos(retval)\n        end.ch--\n        vim.lastHSPos = cm.charCoords(end, 'div').left\n        return retval\n      },\n      moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)))\n      },\n      moveToMatchedSymbol: function (cm, head) {\n        var cursor = head\n        var line = cursor.line\n        var ch = cursor.ch\n        var lineText = cm.getLine(line)\n        var symbol\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch)\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1))\n            if (style !== 'string' && style !== 'comment') {\n              break\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch))\n          return matched.to\n        } else {\n          return cursor\n        }\n      },\n      moveToStartOfLine: function (_cm, head) {\n        return Pos(head.line, 0)\n      },\n      moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine()\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber')\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)))\n      },\n      textObjectManipulation: function (cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')',\n          ')': '(',\n          '{': '}',\n          '}': '{',\n          '[': ']',\n          ']': '['}\n        var selfPaired = {'\\'': true, '\"': true}\n\n        var character = motionArgs.selectedCharacter\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '('\n        } else if (character == 'B') {\n          character = '{'\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner\n\n        var tmp\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive)\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive)\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */)\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */)\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive)\n          motionArgs.linewise = true\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs\n            if (operatorArgs) { operatorArgs.linewise = true }\n            tmp.end.line--\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end]\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end)\n        }\n      },\n\n      repeatLastCharacterSearch: function (cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch\n        var repeat = motionArgs.repeat\n        var forward = motionArgs.forward === lastSearch.forward\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1)\n        cm.moveH(-increment, 'char')\n        motionArgs.inclusive = !!forward\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter)\n        if (!curEnd) {\n          cm.moveH(increment, 'char')\n          return head\n        }\n        curEnd.ch += increment\n        return curEnd\n      }\n    }\n\n    function defineMotion (name, fn) {\n      motions[name] = fn\n    }\n\n    function fillArray (val, times) {\n      var arr = []\n      for (var i = 0; i < times; i++) {\n        arr.push(val)\n      }\n      return arr\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function (cm, args, ranges) {\n        var finalHead, text\n        var vim = cm.state.vim\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n            head = ranges[0].head\n          text = cm.getRange(anchor, head)\n          var lastState = vim.lastEditInputState || {}\n          if (lastState.motion == 'moveByWords' && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text)\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, -match[0].length)\n              text = text.slice(0, -match[0].length)\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE)\n          var wasLastLine = cm.firstLine() == cm.lastLine()\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head)\n          } else {\n            cm.replaceRange('', anchor, head)\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd)\n              CodeMirror.commands.newlineAndIndent(cm)\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE\n          }\n          finalHead = anchor\n        } else {\n          text = cm.getSelection()\n          var replacement = fillArray('', ranges.length)\n          cm.replaceSelections(replacement)\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor)\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1)\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim)\n      },\n      // delete is a javascript keyword.\n      'delete': function (cm, args, ranges) {\n        var finalHead, text\n        var vim = cm.state.vim\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n            head = ranges[0].head\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1))\n            }\n          }\n          text = cm.getRange(anchor, head)\n          cm.replaceRange('', anchor, head)\n          finalHead = anchor\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor)\n          }\n        } else {\n          text = cm.getSelection()\n          var replacement = fillArray('', ranges.length)\n          cm.replaceSelections(replacement)\n          finalHead = ranges[0].anchor\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock)\n        return clipCursorToContent(cm, finalHead)\n      },\n      indent: function (cm, args, ranges) {\n        var vim = cm.state.vim\n        var startLine = ranges[0].anchor.line\n        var endLine = vim.visualBlock\n          ? ranges[ranges.length - 1].anchor.line\n          : ranges[0].head.line\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight)\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor)\n      },\n      changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections()\n        var swapped = []\n        var toLower = args.toLower\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j]\n          var text = ''\n          if (toLower === true) {\n            text = toSwap.toLowerCase()\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase()\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i)\n              text += isUpperCase(character) ? character.toLowerCase()\n                  : character.toUpperCase()\n            }\n          }\n          swapped.push(text)\n        }\n        cm.replaceSelections(swapped)\n        if (args.shouldMoveCursor) {\n          return newHead\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor)\n        } else if (args.linewise) {\n          return oldAnchor\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head)\n        }\n      },\n      yank: function (cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim\n        var text = cm.getSelection()\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock)\n        return endPos\n      }\n    }\n\n    function defineOperator (name, fn) {\n      operators[name] = fn\n    }\n\n    var actions = {\n      jumpListWalk: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return\n        }\n        var repeat = actionArgs.repeat\n        var forward = actionArgs.forward\n        var jumpList = vimGlobalState.jumpList\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat)\n        var markPos = mark ? mark.find() : undefined\n        markPos = markPos || cm.getCursor()\n        cm.setCursor(markPos)\n      },\n      scroll: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return\n        }\n        var repeat = actionArgs.repeat || 1\n        var lineHeight = cm.defaultTextHeight()\n        var top = cm.getScrollInfo().top\n        var delta = lineHeight * repeat\n        var newPos = actionArgs.forward ? top + delta : top - delta\n        var cursor = copyCursor(cm.getCursor())\n        var cursorCoords = cm.charCoords(cursor, 'local')\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n            cursor.line += (newPos - cursorCoords.top) / lineHeight\n            cursor.line = Math.ceil(cursor.line)\n            cm.setCursor(cursor)\n            cursorCoords = cm.charCoords(cursor, 'local')\n            cm.scrollTo(null, cursorCoords.top)\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos)\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight\n          if (newBottom < cursorCoords.bottom) {\n            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight\n            cursor.line = Math.floor(cursor.line)\n            cm.setCursor(cursor)\n            cursorCoords = cm.charCoords(cursor, 'local')\n            cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight)\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos)\n          }\n        }\n      },\n      scrollToCursor: function (cm, actionArgs) {\n        var lineNum = cm.getCursor().line\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local')\n        var height = cm.getScrollInfo().clientHeight\n        var y = charCoords.top\n        var lineHeight = charCoords.bottom - y\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight\n            break\n          case 'bottom': y = y - height + lineHeight\n            break\n        }\n        cm.scrollTo(null, y)\n      },\n      replayMacro: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter\n        var repeat = actionArgs.repeat\n        var macroModeState = vimGlobalState.macroModeState\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister\n        }\n        while (repeat--) {\n          executeMacroRegister(cm, vim, macroModeState, registerName)\n        }\n      },\n      enterMacroRecordMode: function (cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState\n        var registerName = actionArgs.selectedCharacter\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName)\n        }\n      },\n      toggleOverwrite: function (cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true)\n          cm.setOption('keyMap', 'vim-replace')\n          CodeMirror.signal(cm, 'vim-mode-change', {mode: 'replace'})\n        } else {\n          cm.toggleOverwrite(false)\n          cm.setOption('keyMap', 'vim-insert')\n          CodeMirror.signal(cm, 'vim-mode-change', {mode: 'insert'})\n        }\n      },\n      enterInsertMode: function (cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return }\n        cm.getWrapperElement().classList.add('insert-mode')\n        cm.getWrapperElement().classList.remove('visual-mode')\n        cm.getWrapperElement().classList.remove('normal-mode')\n        vim.insertMode = true\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null\n        var sel = vim.sel\n        var head = actionArgs.head || cm.getCursor('head')\n        var height = cm.listSelections().length\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line))\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1)\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head)\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head\n            } else {\n              head = Pos(sel.anchor.line, 0)\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch))\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1)\n            } else {\n              head = Pos(sel.anchor.line, 0)\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch))\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode) {\n            return\n          }\n        }\n        cm.setOption('disableInput', false)\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true)\n          cm.setOption('keyMap', 'vim-replace')\n          CodeMirror.signal(cm, 'vim-mode-change', {mode: 'replace'})\n        } else {\n          cm.toggleOverwrite(false)\n          cm.setOption('keyMap', 'vim-insert')\n          CodeMirror.signal(cm, 'vim-mode-change', {mode: 'insert'})\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange)\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown)\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm)\n        }\n        selectForInsert(cm, head, height)\n      },\n      toggleVisualMode: function (cm, actionArgs, vim) {\n        debug('toggleVisualMode', actionArgs)\n        var repeat = actionArgs.repeat\n        var anchor = cm.getCursor()\n        var head\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true\n          vim.visualLine = !!actionArgs.linewise\n          vim.visualBlock = !!actionArgs.blockwise\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */)\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          }\n          CodeMirror.signal(cm, 'vim-mode-change', {mode: 'visual', subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''})\n          updateCmSelection(cm)\n          updateMark(cm, vim, '<', cursorMin(anchor, head))\n          updateMark(cm, vim, '>', cursorMax(anchor, head))\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise\n          vim.visualBlock = !!actionArgs.blockwise\n          CodeMirror.signal(cm, 'vim-mode-change', {mode: 'visual', subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''})\n          updateCmSelection(cm)\n        } else {\n          exitVisualMode(cm)\n        }\n      },\n      reselectLastSelection: function (cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim)\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find()\n          var head = lastSelection.headMark.find()\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          }\n          vim.visualMode = true\n          vim.visualLine = lastSelection.visualLine\n          vim.visualBlock = lastSelection.visualBlock\n          updateCmSelection(cm)\n          updateMark(cm, vim, '<', cursorMin(anchor, head))\n          updateMark(cm, vim, '>', cursorMax(anchor, head))\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise'\n                     : vim.visualBlock ? 'blockwise' : ''})\n        }\n      },\n      joinLines: function (cm, actionArgs, vim) {\n        var curStart, curEnd\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor')\n          curEnd = cm.getCursor('head')\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd\n            curEnd = curStart\n            curStart = tmp\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2)\n          curStart = cm.getCursor()\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity))\n        }\n        var finalCh = 0\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line)\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1))\n          var text = cm.getRange(curStart, tmp)\n          text = text.replace(/\\n\\s*/g, ' ')\n          cm.replaceRange(text, curStart, tmp)\n        }\n        var curFinalPos = Pos(curStart.line, finalCh)\n        if (vim.visualMode) {\n          exitVisualMode(cm, false)\n        }\n        cm.setCursor(curFinalPos)\n      },\n      newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n        vim.insertMode = true\n        var insertAt = copyCursor(cm.getCursor())\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0))\n          cm.setCursor(cm.firstLine(), 0)\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line\n              : insertAt.line - 1\n          insertAt.ch = lineLength(cm, insertAt.line)\n          cm.setCursor(insertAt)\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent\n          newlineFn(cm)\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim)\n      },\n      paste: function (cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor())\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName)\n        var text = register.toString()\n        if (!text) {\n          return\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption('tabSize')\n          // length that considers tabs and tabSize\n          var whitespaceLength = function (str) {\n            var tabs = (str.split('\\t').length - 1)\n            var spaces = (str.split(' ').length - 1)\n            return tabs * tabSize + spaces * 1\n          }\n          var currentLine = cm.getLine(cm.getCursor().line)\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0])\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '')\n          var wasChomped = text !== chompedText\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0])\n          var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent)\n            if (newIndent < 0) {\n              return ''\n            } else if (cm.getOption('indentWithTabs')) {\n              var quotient = Math.floor(newIndent / tabSize)\n              return Array(quotient + 1).join('\\t')\n            } else {\n              return Array(newIndent + 1).join(' ')\n            }\n          })\n          text += wasChomped ? '\\n' : ''\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text)\n        }\n        var linewise = register.linewise\n        var blockwise = register.blockwise\n        if (linewise) {\n          if (vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n'\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1)\n            cur.ch = lineLength(cm, cur.line)\n          } else {\n            cur.ch = 0\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n')\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i]\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0\n        }\n        var curPosFinal\n        var idx\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text\n          var lastSelectionCurEnd\n          var selectedArea = getSelectedAreaRange(cm, vim)\n          var selectionStart = selectedArea[0]\n          var selectionEnd = selectedArea[1]\n          var selectedText = cm.getSelection()\n          var selections = cm.listSelections()\n          var emptyStrings = new Array(selections.length).join('1').split('1')\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find()\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText)\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings)\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length - 1, selectionStart.ch)\n            cm.setCursor(selectionStart)\n            selectBlock(cm, selectionEnd)\n            cm.replaceSelections(text)\n            curPosFinal = selectionStart\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings)\n            cm.setCursor(selectionStart)\n            cm.replaceRange(text, selectionStart, selectionStart)\n            curPosFinal = selectionStart\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd)\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1)\n          }\n          // restore the the curEnd marker\n          if (lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd)\n          }\n          if (linewise) {\n            curPosFinal.ch = 0\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur)\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line + i\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n', Pos(line, 0))\n              }\n              var lastCh = lineLength(cm, line)\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch)\n              }\n            }\n            cm.setCursor(cur)\n            selectBlock(cm, Pos(cur.line + text.length - 1, cur.ch))\n            cm.replaceSelections(text)\n            curPosFinal = cur\n          } else {\n            cm.replaceRange(text, cur)\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)))\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)))\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur)\n              curPosFinal = cm.posFromIndex(idx + text.length - 1)\n            } else {\n              idx = cm.indexFromPos(cur)\n              curPosFinal = cm.posFromIndex(idx + text.length)\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false)\n        }\n        cm.setCursor(curPosFinal)\n      },\n      undo: function (cm, actionArgs) {\n        cm.operation(function () {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)()\n          cm.setCursor(cm.getCursor('anchor'))\n        })\n      },\n      redo: function (cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)()\n      },\n      setRegister: function (_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter\n      },\n      setMark: function (cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter\n        updateMark(cm, vim, markName, cm.getCursor())\n      },\n      replace: function (cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter\n        var curStart = cm.getCursor()\n        var replaceTo\n        var curEnd\n        var selections = cm.listSelections()\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start')\n          curEnd = cm.getCursor('end')\n        } else {\n          var line = cm.getLine(curStart.line)\n          replaceTo = curStart.ch + actionArgs.repeat\n          if (replaceTo > line.length) {\n            replaceTo = line.length\n          }\n          curEnd = Pos(curStart.line, replaceTo)\n        }\n        if (replaceWith == '\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm)\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd)\n          // replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith)\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption('tabSize') + 1).join(' ')\n            replaceWithStr = cm.getSelection()\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n')\n            cm.replaceSelections(replaceWithStr)\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd)\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head)\n                         ? selections[0].anchor : selections[0].head\n            cm.setCursor(curStart)\n            exitVisualMode(cm, false)\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1))\n          }\n        }\n      },\n      incrementNumberToken: function (cm, actionArgs) {\n        var cur = cm.getCursor()\n        var lineStr = cm.getLine(cur.line)\n        var re = /-?\\d+/g\n        var match\n        var start\n        var end\n        var numberStr\n        var token\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0]\n          start = match.index\n          end = start + token.length\n          if (cur.ch < end) break\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch)) return\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1\n          var number = parseInt(token) + (increment * actionArgs.repeat)\n          var from = Pos(cur.line, start)\n          var to = Pos(cur.line, end)\n          numberStr = number.toString()\n          cm.replaceRange(numberStr, from, to)\n        } else {\n          return\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1))\n      },\n      repeatLastEdit: function (cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState\n        if (!lastEditInputState) { return }\n        var repeat = actionArgs.repeat\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */)\n      },\n      indent: function (cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight)\n      },\n      exitInsertMode: exitInsertMode\n    }\n\n    function defineAction (name, fn) {\n      actions[name] = fn\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent (cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine())\n      var maxCh = lineLength(cm, line) - 1\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh\n      var ch = Math.min(Math.max(0, cur.ch), maxCh)\n      return Pos(line, ch)\n    }\n    function copyArgs (args) {\n      var ret = {}\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop]\n        }\n      }\n      return ret\n    }\n    function offsetCursor (cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch\n        offsetLine = offsetLine.line\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh)\n    }\n    function getOffset (anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      }\n    }\n    function commandMatches (keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = []\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i]\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue }\n        if (match == 'partial') { partial.push(command) }\n        if (match == 'full') { full.push(command) }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      }\n    }\n    function commandMatch (pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11\n        var pressedPrefix = pressed.slice(0, prefixLen)\n        var mappedPrefix = mapped.slice(0, prefixLen)\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full'\n               : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false\n      } else {\n        return pressed == mapped ? 'full'\n               : mapped.indexOf(pressed) == 0 ? 'partial' : false\n      }\n    }\n    function lastChar (keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys)\n      var selectedCharacter = match ? match[1] : keys.slice(-1)\n      if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n          case '<CR>':\n            selectedCharacter = '\\n'\n            break\n          case '<Space>':\n            selectedCharacter = ' '\n            break\n          default:\n            selectedCharacter = ''\n            break\n        }\n      }\n      return selectedCharacter\n    }\n    function repeatFn (cm, fn, repeat) {\n      return function () {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm)\n        }\n      }\n    }\n    function copyCursor (cur) {\n      return Pos(cur.line, cur.ch)\n    }\n    function cursorEqual (cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line\n    }\n    function cursorIsBefore (cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true\n      }\n      return false\n    }\n    function cursorMin (cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1))\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2\n    }\n    function cursorMax (cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1))\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1\n    }\n    function cursorIsBetween (cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2)\n      var cur2before3 = cursorIsBefore(cur2, cur3)\n      return cur1before2 && cur2before3\n    }\n    function lineLength (cm, lineNum) {\n      return cm.getLine(lineNum).length\n    }\n    function trim (s) {\n      if (s.trim) {\n        return s.trim()\n      }\n      return s.replace(/^\\s+|\\s+$/g, '')\n    }\n    function escapeRegex (s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1')\n    }\n    function extendLineToColumn (cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum)\n      var spaces = new Array(column - endCh + 1).join(' ')\n      cm.setCursor(Pos(lineNum, endCh))\n      cm.replaceRange(spaces, cm.getCursor())\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock (cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections()\n      var head = copyCursor(cm.clipPos(selectionEnd))\n      var isClipped = !cursorEqual(selectionEnd, head)\n      var curHead = cm.getCursor('head')\n      var primIndex = getIndex(ranges, curHead)\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor)\n      var max = ranges.length - 1\n      var index = max - primIndex > primIndex ? max : 0\n      var base = ranges[index].anchor\n\n      var firstLine = Math.min(base.line, head.line)\n      var lastLine = Math.max(base.line, head.line)\n      var baseCh = base.ch, headCh = head.ch\n\n      var dir = ranges[index].head.ch - baseCh\n      var newDir = headCh - baseCh\n      if (dir > 0 && newDir <= 0) {\n        baseCh++\n        if (!isClipped) { headCh-- }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--\n        if (!wasClipped) { headCh++ }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--\n        headCh++\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)}\n        selections.push(range)\n      }\n      cm.setSelections(selections)\n      selectionEnd.ch = headCh\n      base.ch = baseCh\n      return base\n    }\n    function selectForInsert (cm, head, height) {\n      var sel = []\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0)\n        sel.push({anchor: lineHead, head: lineHead})\n      }\n      cm.setSelections(sel, 0)\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex (ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor)\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor)\n        if (atAnchor || atHead) {\n          return i\n        }\n      }\n      return -1\n    }\n    function getSelectedAreaRange (cm, vim) {\n      var lastSelection = vim.lastSelection\n      var getCurrentSelectedAreaRange = function () {\n        var selections = cm.listSelections()\n        var start = selections[0]\n        var end = selections[selections.length - 1]\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor\n        return [selectionStart, selectionEnd]\n      }\n      var getLastSelectedAreaRange = function () {\n        var selectionStart = cm.getCursor()\n        var selectionEnd = cm.getCursor()\n        var block = lastSelection.visualBlock\n        if (block) {\n          var width = block.width\n          var height = block.height\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width)\n          var selections = []\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch)\n            var head = Pos(i, selectionEnd.ch)\n            var range = {anchor: anchor, head: head}\n            selections.push(range)\n          }\n          cm.setSelections(selections)\n        } else {\n          var start = lastSelection.anchorMark.find()\n          var end = lastSelection.headMark.find()\n          var line = end.line - start.line\n          var ch = end.ch - start.ch\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch}\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0)\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line))\n          }\n          cm.setSelection(selectionStart, selectionEnd)\n        }\n        return [selectionStart, selectionEnd]\n      }\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange()\n      } else {\n        return getCurrentSelectedAreaRange()\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection (cm, vim) {\n      var anchor = vim.sel.anchor\n      var head = vim.sel.head\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length)\n        vim.lastPastedText = null\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock}\n    }\n    function expandSelection (cm, start, end) {\n      var sel = cm.state.vim.sel\n      var head = sel.head\n      var anchor = sel.anchor\n      var tmp\n      if (cursorIsBefore(end, start)) {\n        tmp = end\n        end = start\n        start = tmp\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head)\n        anchor = cursorMax(anchor, end)\n      } else {\n        anchor = cursorMin(start, anchor)\n        head = cursorMax(head, end)\n        head = offsetCursor(head, 0, -1)\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1))\n        }\n      }\n      return [anchor, head]\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection (cm, sel, mode) {\n      var vim = cm.state.vim\n      sel = sel || vim.sel\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char'\n      var cmSel = makeCmSelection(cm, sel, mode)\n      cm.setSelections(cmSel.ranges, cmSel.primary)\n      updateFakeCursor(cm)\n    }\n    function makeCmSelection (cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head)\n      var anchor = copyCursor(sel.anchor)\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0\n        head = offsetCursor(sel.head, 0, headOffset)\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset)\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        }\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0\n\n          var lastLine = cm.lastLine()\n          if (head.line > lastLine) {\n            head.line = lastLine\n          }\n          head.ch = lineLength(cm, head.line)\n        } else {\n          head.ch = 0\n          anchor.ch = lineLength(cm, anchor.line)\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        }\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n          left = Math.min(anchor.ch, head.ch),\n          bottom = Math.max(anchor.line, head.line),\n          right = Math.max(anchor.ch, head.ch) + 1\n        var height = bottom - top + 1\n        var primary = head.line == top ? 0 : height - 1\n        var ranges = []\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          })\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        }\n      }\n    }\n    function getHead (cm) {\n      var cur = cm.getCursor('head')\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'))\n      }\n      return cur\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode (cm, moveHead) {\n      var vim = cm.state.vim\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head))\n      }\n      updateLastSelection(cm, vim)\n      vim.visualMode = false\n      vim.visualLine = false\n      vim.visualBlock = false\n      CodeMirror.signal(cm, 'vim-mode-change', {mode: 'normal'})\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear()\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine (cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd)\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n')\n        // We know this is all whitespace.\n        lines.pop()\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--\n          curEnd.ch = 0\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--\n          curEnd.ch = lineLength(cm, curEnd.line)\n        } else {\n          curEnd.ch = 0\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine (_cm, curStart, curEnd) {\n      curStart.ch = 0\n      curEnd.ch = 0\n      curEnd.line++\n    }\n\n    function findFirstNonWhiteSpaceCharacter (text) {\n      if (!text) {\n        return 0\n      }\n      var firstNonWS = text.search(/\\S/)\n      return firstNonWS == -1 ? text.length : firstNonWS\n    }\n\n    function expandWordUnderCursor (cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm)\n      var line = cm.getLine(cur.line)\n      var idx = cur.ch\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0]\n      while (!test(line.charAt(idx))) {\n        idx++\n        if (idx >= line.length) { return null }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0]\n      } else {\n        test = wordCharTest[0]\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1]\n        }\n      }\n\n      var end = idx, start = idx\n      while (test(line.charAt(end)) && end < line.length) { end++ }\n      while (test(line.charAt(start)) && start >= 0) { start-- }\n      start++\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++ }\n        if (wordEnd == end) {\n          var wordStart = start\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start-- }\n          if (!start) { start = wordStart }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) }\n    }\n\n    function recordJumpPosition (cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur)\n      }\n    }\n\n    function recordLastCharacterSearch (increment, args) {\n      vimGlobalState.lastCharacterSearch.increment = increment\n      vimGlobalState.lastCharacterSearch.forward = args.forward\n      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter\n    }\n\n    var symbolToMode = {\n      '(': 'bracket',\n      ')': 'bracket',\n      '{': 'bracket',\n      '}': 'bracket',\n      '[': 'section',\n      ']': 'section',\n      '*': 'comment',\n      '/': 'comment',\n      'm': 'method',\n      'M': 'method',\n      '#': 'preprocess'\n    }\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function (state) {\n          if (state.nextCh === state.symb) {\n            state.depth++\n            if (state.depth >= 1) return true\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--\n          }\n          return false\n        }\n      },\n      section: {\n        init: function (state) {\n          state.curMoveThrough = true\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}'\n        },\n        isComplete: function (state) {\n          return state.index === 0 && state.nextCh === state.symb\n        }\n      },\n      comment: {\n        isComplete: function (state) {\n          var found = state.lastCh === '*' && state.nextCh === '/'\n          state.lastCh = state.nextCh\n          return found\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function (state) {\n          state.symb = (state.symb === 'm' ? '{' : '}')\n          state.reverseSymb = state.symb === '{' ? '}' : '{'\n        },\n        isComplete: function (state) {\n          if (state.nextCh === state.symb) return true\n          return false\n        }\n      },\n      preprocess: {\n        init: function (state) {\n          state.index = 0\n        },\n        isComplete: function (state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1]\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true\n              }\n              state.depth++\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true\n              }\n              state.depth--\n            }\n            if (token === 'else' && state.depth === 0) return true\n          }\n          return false\n        }\n      }\n    }\n    function findSymbol (cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor())\n      var increment = forward ? 1 : -1\n      var endLine = forward ? cm.lineCount() : -1\n      var curCh = cur.ch\n      var line = cur.line\n      var lineText = cm.getLine(line)\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      }\n      var mode = symbolToMode[symb]\n      if (!mode) return cur\n      var init = findSymbolModes[mode].init\n      var isComplete = findSymbolModes[mode].isComplete\n      if (init) { init(state) }\n      while (line !== endLine && repeat) {\n        state.index += increment\n        state.nextCh = state.lineText.charAt(state.index)\n        if (!state.nextCh) {\n          line += increment\n          state.lineText = cm.getLine(line) || ''\n          if (increment > 0) {\n            state.index = 0\n          } else {\n            var lineLen = state.lineText.length\n            state.index = (lineLen > 0) ? (lineLen - 1) : 0\n          }\n          state.nextCh = state.lineText.charAt(state.index)\n        }\n        if (isComplete(state)) {\n          cur.line = line\n          cur.ch = state.index\n          repeat--\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index)\n      }\n      return cur\n    }\n\n    /**\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord (cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line\n      var pos = cur.ch\n      var line = cm.getLine(lineNum)\n      var dir = forward ? 1 : -1\n      var charTests = bigWord ? bigWordCharTest : wordCharTest\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir\n        line = cm.getLine(lineNum)\n        if (!isLine(cm, lineNum)) {\n          return null\n        }\n        pos = (forward) ? 0 : line.length\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum }\n        }\n        var stop = (dir > 0) ? line.length : -1\n        var wordStart = stop, wordEnd = stop\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir\n              }\n              wordEnd = pos\n              foundWord = wordStart != wordEnd\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum }\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir\n        if (!isLine(cm, lineNum)) {\n          return null\n        }\n        line = cm.getLine(lineNum)\n        pos = (dir > 0) ? 0 : line.length\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord (cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur)\n      var words = []\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd)\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord)\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine())\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0})\n          break\n        }\n        words.push(word)\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from)\n      }\n      var shortCircuit = words.length != repeat\n      var firstWord = words[0]\n      var lastWord = words.pop()\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop()\n        }\n        return Pos(lastWord.line, lastWord.from)\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1)\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop()\n        }\n        return Pos(lastWord.line, lastWord.to)\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from)\n      }\n    }\n\n    function moveToCharacter (cm, repeat, forward, character) {\n      var cur = cm.getCursor()\n      var start = cur.ch\n      var idx\n      for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line)\n        idx = charIdxInLine(start, line, character, forward, true)\n        if (idx == -1) {\n          return null\n        }\n        start = idx\n      }\n      return Pos(cm.getCursor().line, idx)\n    }\n\n    function moveToColumn (cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line\n      return clipCursorToContent(cm, Pos(line, repeat - 1))\n    }\n\n    function updateMark (cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear()\n      }\n      vim.marks[markName] = cm.setBookmark(pos)\n    }\n\n    function charIdxInLine (start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx\n      if (forward) {\n        idx = line.indexOf(character, start + 1)\n        if (idx != -1 && !includeChar) {\n          idx -= 1\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1)\n        if (idx != -1 && !includeChar) {\n          idx += 1\n        }\n      }\n      return idx\n    }\n\n    function findParagraph (cm, head, repeat, dir, inclusive) {\n      var line = head.line\n      var min = cm.firstLine()\n      var max = cm.lastLine()\n      var start, end, i = line\n      function isEmpty (i) { return !cm.getLine(i) }\n      function isBoundary (i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir) }\n        return !isEmpty(i) && isEmpty(i + dir)\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat-- }\n          i += dir\n        }\n        return new Pos(i, 0)\n      }\n\n      var vim = cm.state.vim\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1\n          }\n        }\n      }\n      var startState = isEmpty(line)\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--\n          }\n        }\n      }\n      end = new Pos(i, 0)\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true } else { inclusive = false }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break }\n        }\n      }\n      start = new Pos(i, 0)\n      return { start: start, end: end }\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject (cm, head, symb, inclusive) {\n      var cur = head, start, end\n\n      var bracketRegexp = ({\n        '(': /[()]/,\n        ')': /[()]/,\n        '[': /[[\\]]/,\n        ']': /[[\\]]/,\n        '{': /[{}]/,\n        '}': /[{}]/})[symb]\n      var openSym = ({\n        '(': '(',\n        ')': '(',\n        '[': '[',\n        ']': '[',\n        '{': '{',\n        '}': '{'})[symb]\n      var curChar = cm.getLine(cur.line).charAt(cur.ch)\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp})\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp})\n\n      if (!start || !end) {\n        return { start: cur, end: cur }\n      }\n\n      start = start.pos\n      end = end.pos\n\n      if ((start.line == end.line && start.ch > end.ch) ||\n          (start.line > end.line)) {\n        var tmp = start\n        start = end\n        end = tmp\n      }\n\n      if (inclusive) {\n        end.ch += 1\n      } else {\n        start.ch += 1\n      }\n\n      return { start: start, end: end }\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd (cm, head, symb, inclusive) {\n      var cur = copyCursor(head)\n      var line = cm.getLine(cur.line)\n      var chars = line.split('')\n      var start, end, i, len\n      var firstIndex = chars.indexOf(symb)\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch // assign end to the current cursor\n        --cur.ch // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1 // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur }\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      }\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean')\n    function SearchState () {}\n    SearchState.prototype = {\n      getQuery: function () {\n        return vimGlobalState.query\n      },\n      setQuery: function (query) {\n        vimGlobalState.query = query\n      },\n      getOverlay: function () {\n        return this.searchOverlay\n      },\n      setOverlay: function (overlay) {\n        this.searchOverlay = overlay\n      },\n      isReversed: function () {\n        return vimGlobalState.isReversed\n      },\n      setReversed: function (reversed) {\n        vimGlobalState.isReversed = reversed\n      },\n      getScrollbarAnnotate: function () {\n        return this.annotate\n      },\n      setScrollbarAnnotate: function (annotate) {\n        this.annotate = annotate\n      }\n    }\n    function getSearchState (cm) {\n      var vim = cm.state.vim\n      return vim.searchState_ || (vim.searchState_ = new SearchState())\n    }\n    function dialog (cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true,\n          value: options.value,\n          onKeyDown: options.onKeyDown,\n          onKeyUp: options.onKeyUp,\n          selectValueOnOpen: false})\n      } else {\n        onClose(prompt(shortText, ''))\n      }\n    }\n    function splitBySlash (argString) {\n      var slashes = findUnescapedSlashes(argString) || []\n      if (!slashes.length) return []\n      var tokens = []\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] === 'number') { tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1])) }\n      }\n      return tokens\n    }\n\n    function findUnescapedSlashes (str) {\n      var escapeNextChar = false\n      var slashes = []\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i)\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i)\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\')\n      }\n      return slashes\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex (str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){'\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}'\n      var escapeNextChar = false\n      var out = []\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || ''\n        var n = str.charAt(i + 1) || ''\n        var specialComesNext = (n && specials.indexOf(n) != -1)\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c)\n          }\n          escapeNextChar = false\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c)\n            }\n          } else {\n            out.push(c)\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\')\n            }\n          }\n        }\n      }\n      return out.join('')\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'}\n    function translateRegexReplace (str) {\n      var escapeNextChar = false\n      var out = []\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || ''\n        var n = str.charAt(i + 1) || ''\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c + n])\n          i++\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c)\n          escapeNextChar = false\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true\n            if ((isNumber(n) || n === '$')) {\n              out.push('$')\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\')\n            }\n          } else {\n            if (c === '$') {\n              out.push('$')\n            }\n            out.push(c)\n            if (n === '/') {\n              out.push('\\\\')\n            }\n          }\n        }\n      }\n      return out.join('')\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'}\n    function unescapeRegexReplace (str) {\n      var stream = new CodeMirror.StringStream(str)\n      var output = []\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next())\n        }\n        var matched = false\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true\n            output.push(unescapes[matcher])\n            break\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next())\n        }\n      }\n      return output.join('')\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery (query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/')\n      lastSearchRegister.setText(query)\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query)\n      var regexPart\n      var forceIgnoreCase\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0])\n        var flagsPart = query.substring(slashes[0])\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1)\n      }\n      if (!regexPart) {\n        return null\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart)\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart)\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined)\n      return regexp\n    }\n    function showConfirm (cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000})\n      } else {\n        alert(text)\n      }\n    }\n    function makePrompt (prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || '') + '<input type=\"text\"></span>'\n      if (desc) { raw += ' <span style=\"color: #888\">' + desc + '</span>' }\n      return raw\n    }\n    var searchPromptDesc = '(Javascript regexp)'\n    function showPrompt (cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '')\n      var prompt = makePrompt(options.prefix, options.desc)\n      dialog(cm, prompt, shortText, options.onClose, options)\n    }\n    function regexEqual (r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source']\n        for (var i = 0; i < props.length; i++) {\n          var prop = props[i]\n          if (r1[prop] !== r2[prop]) {\n            return false\n          }\n        }\n        return true\n      }\n      return false\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery (cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return\n      }\n      var state = getSearchState(cm)\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase)\n      if (!query) {\n        return\n      }\n      highlightSearchMatches(cm, query)\n      if (regexEqual(query, state.getQuery())) {\n        return query\n      }\n      state.setQuery(query)\n      return query\n    }\n    function searchOverlay (query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true\n      }\n      return {\n        token: function (stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd()\n            return\n          }\n          var match = stream.match(query, false)\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next()\n              return 'searching'\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1)\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next()\n                return null\n              }\n            }\n            stream.match(query)\n            return 'searching'\n          }\n          while (!stream.eol()) {\n            stream.next()\n            if (stream.match(query, false)) break\n          }\n        },\n        query: query\n      }\n    }\n    function highlightSearchMatches (cm, query) {\n      var searchState = getSearchState(cm)\n      var overlay = searchState.getOverlay()\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay)\n        }\n        overlay = searchOverlay(query)\n        cm.addOverlay(overlay)\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear()\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query))\n        }\n        searchState.setOverlay(overlay)\n      }\n    }\n    function findNext (cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1 }\n      return cm.operation(function () {\n        var pos = cm.getCursor()\n        var cursor = cm.getSearchCursor(query, pos)\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev)\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev) }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0))\n            if (!cursor.find(prev)) {\n              return\n            }\n          }\n        }\n        return cursor.from()\n      })\n    }\n    function clearSearchHighlight (cm) {\n      var state = getSearchState(cm)\n      cm.removeOverlay(getSearchState(cm).getOverlay())\n      state.setOverlay(null)\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear()\n        state.setScrollbarAnnotate(null)\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange (pos, start, end) {\n      if (typeof pos !== 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start)\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end)\n        } else {\n          return pos == start\n        }\n      }\n    }\n    function getUserVisibleLines (cm) {\n      var scrollInfo = cm.getScrollInfo()\n      var occludeToleranceTop = 6\n      var occludeToleranceBottom = 10\n      var from = cm.coordsChar({left: 0, top: occludeToleranceTop + scrollInfo.top}, 'local')\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top\n      var to = cm.coordsChar({left: 0, top: bottomY}, 'local')\n      return {top: from.line, bottom: to.line}\n    }\n\n    function getMarkPos (cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done\n        var event = history[history.length - 2]\n        return event && event.ranges && event.ranges[0].head\n      }\n\n      var mark = vim.marks[markName]\n      return mark && mark.find()\n    }\n\n    var ExCommandDispatcher = function () {\n      this.buildCommandMap_()\n    }\n    ExCommandDispatcher.prototype = {\n      processCommand: function (cm, input, opt_params) {\n        var that = this\n        cm.operation(function () {\n          cm.curOp.isVimOp = true\n          that._processCommand(cm, input, opt_params)\n        })\n      },\n      _processCommand: function (cm, input, opt_params) {\n        var vim = cm.state.vim\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':')\n        var previousCommand = commandHistoryRegister.toString()\n        if (vim.visualMode) {\n          exitVisualMode(cm)\n        }\n        var inputStream = new CodeMirror.StringStream(input)\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input)\n        var params = opt_params || {}\n        params.input = input\n        try {\n          this.parseInput_(cm, inputStream, params)\n        } catch (e) {\n          showConfirm(cm, e)\n          throw e\n        }\n        var command\n        var commandName\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move'\n          }\n        } else {\n          command = this.matchCommand_(params.commandName)\n          if (command) {\n            commandName = command.name\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand)\n            }\n            this.parseCommandArgs_(inputStream, params, command)\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping')\n              }\n              return\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput)\n              return\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"')\n          return\n        }\n        try {\n          exCommands[commandName](cm, params)\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback()\n          }\n        } catch (e) {\n          showConfirm(cm, e)\n          throw e\n        }\n      },\n      parseInput_: function (cm, inputStream, result) {\n        inputStream.eatWhile(':')\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine()\n          result.lineEnd = cm.lastLine()\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream)\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream)\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/)\n        if (commandMatch) {\n          result.commandName = commandMatch[1]\n        } else {\n          result.commandName = inputStream.match(/.*/)[0]\n        }\n\n        return result\n      },\n      parseLineSpec_: function (cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/)\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line)\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine())\n          case '\\'':\n            var markName = inputStream.next()\n            var markPos = getMarkPos(cm, cm.state.vim, markName)\n            if (!markPos) throw new Error('Mark not set')\n            return this.parseLineSpecOffset_(inputStream, markPos.line)\n          case '-':\n          case '+':\n            inputStream.backUp(1)\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line)\n          default:\n            inputStream.backUp(1)\n            return undefined\n        }\n      },\n      parseLineSpecOffset_: function (inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/)\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10)\n          if (offsetMatch[1] == '-') {\n            line -= offset\n          } else {\n            line += offset\n          }\n        }\n        return line\n      },\n      parseCommandArgs_: function (inputStream, params, command) {\n        if (inputStream.eol()) {\n          return\n        }\n        params.argString = inputStream.match(/.*/)[0]\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/\n        var args = trim(params.argString).split(delim)\n        if (args.length && args[0]) {\n          params.args = args\n        }\n      },\n      matchCommand_: function (commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i)\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix]\n            if (command.name.indexOf(commandName) === 0) {\n              return command\n            }\n          }\n        }\n        return null\n      },\n      buildCommandMap_: function () {\n        this.commandMap_ = {}\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i]\n          var key = command.shortName || command.name\n          this.commandMap_[key] = command\n        }\n      },\n      map: function (lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings') }\n          var commandName = lhs.substring(1)\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            }\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            }\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            }\n            if (ctx) { mapping.context = ctx }\n            defaultKeymap.unshift(mapping)\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            }\n            if (ctx) { mapping.context = ctx }\n            defaultKeymap.unshift(mapping)\n          }\n        }\n      },\n      unmap: function (lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings') }\n          var commandName = lhs.substring(1)\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName]\n            return\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys &&\n                defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1)\n              return\n            }\n          }\n        }\n        throw Error('No such mapping.')\n      }\n    }\n\n    var exCommands = {\n      colorscheme: function (cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'))\n          return\n        }\n        cm.setOption('theme', params.args[0])\n      },\n      map: function (cm, params, ctx) {\n        var mapArgs = params.args\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input)\n          }\n          return\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx)\n      },\n      imap: function (cm, params) { this.map(cm, params, 'insert') },\n      nmap: function (cm, params) { this.map(cm, params, 'normal') },\n      vmap: function (cm, params) { this.map(cm, params, 'visual') },\n      unmap: function (cm, params, ctx) {\n        var mapArgs = params.args\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input)\n          }\n          return\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx)\n      },\n      move: function (cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n          type: 'motion',\n          motion: 'moveToLineOrEdgeOfDocument',\n          motionArgs: { forward: false,\n            explicitRepeat: true,\n            linewise: true },\n          repeatOverride: params.line + 1})\n      },\n      set: function (cm, params) {\n        var setArgs = params.args\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {}\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input)\n          }\n          return\n        }\n        var expr = setArgs[0].split('=')\n        var optionName = expr[0]\n        var value = expr[1]\n        var forceGet = false\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString) }\n          optionName = optionName.substring(0, optionName.length - 1)\n          forceGet = true\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2)\n          value = false\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean'\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg)\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message)\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName)\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue)\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg)\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message)\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'}\n        this.set(cm, params)\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'}\n        this.set(cm, params)\n      },\n      registers: function (cm, params) {\n        var regArgs = params.args\n        var registers = vimGlobalState.registerController.registers\n        var regInfo = '----------Registers----------<br><br>'\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString()\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>'\n            }\n          }\n        } else {\n          var registerName\n          regArgs = regArgs.join('')\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i)\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue\n            }\n            var register = registers[registerName] || new Register()\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>'\n          }\n        }\n        showConfirm(cm, regInfo)\n      },\n      sort: function (cm, params) {\n        var reverse, ignoreCase, unique, number, pattern\n        function parseArgs () {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString)\n            if (args.eat('!')) { reverse = true }\n            if (args.eol()) { return }\n            if (!args.eatSpace()) { return 'Invalid arguments' }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/)\n            if (!opts && !args.eol()) { return 'Invalid arguments' }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1\n              unique = opts[1].indexOf('u') != -1\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1\n              var hex = opts[1].indexOf('x') != -1 && 1\n              var octal = opts[1].indexOf('o') != -1 && 1\n              if (decimal + hex + octal > 1) { return 'Invalid arguments' }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal'\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '')\n            }\n          }\n        }\n        var err = parseArgs()\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString)\n          return\n        }\n        var lineStart = params.line || cm.firstLine()\n        var lineEnd = params.lineEnd || params.line || cm.lastLine()\n        if (lineStart == lineEnd) { return }\n        var curStart = Pos(lineStart, 0)\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd))\n        var text = cm.getRange(curStart, curEnd).split('\\n')\n        var numberRegex = pattern || (number == 'decimal') ? /(-?)([\\d]+)/\n           : (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i\n           : (number == 'octal') ? /([0-7]+)/ : null\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null\n        var numPart = [], textPart = []\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart)\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i])\n            } else {\n              textPart.push(text[i])\n            }\n          }\n        } else {\n          textPart = text\n        }\n        function compareFn (a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase() }\n          var anum = number && numberRegex.exec(a)\n          var bnum = number && numberRegex.exec(b)\n          if (!anum) { return a < b ? -1 : 1 }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix)\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix)\n          return anum - bnum\n        }\n        function comparePatternFn (a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase() }\n          return (a[0] < b[0]) ? -1 : 1\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn)\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input\n          }\n        } else if (!number) { textPart.sort(compareFn) }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart)\n        if (unique) { // Remove duplicate lines\n          var textOld = text\n          var lastLine\n          text = []\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i])\n            }\n            lastLine = textOld[i]\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd)\n      },\n      global: function (cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global')\n          return\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine()\n        var lineEnd = params.lineEnd || params.line || cm.lastLine()\n        // get the tokens from argString\n        var tokens = splitBySlash(argString)\n        var regexPart = argString, cmd\n        if (tokens.length) {\n          regexPart = tokens[0]\n          cmd = tokens.slice(1, tokens.length).join('/')\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */)\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart)\n            return\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery()\n        var matchedLines = [], content = ''\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i))\n          if (matched) {\n            matchedLines.push(i + 1)\n            content += cm.getLine(i) + '<br>'\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content)\n          return\n        }\n        var index = 0\n        var nextCommand = function () {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            })\n          }\n          index++\n        }\n        nextCommand()\n      },\n      substitute: function (cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.')\n        }\n        var argString = params.argString\n        var tokens = argString ? splitBySlash(argString) : []\n        var regexPart, replacePart = '', trailing, flagsPart, count\n        var confirm = false // Whether to confirm each replace.\n        var global = false // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0]\n          replacePart = tokens[1]\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n'\n            replacePart = replacePart ? replacePart + '\\n' : '\\n'\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart)\n            } else {\n              replacePart = translateRegexReplace(replacePart)\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : []\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/')\n            return\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0]\n          count = parseInt(trailing[1])\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true\n              flagsPart.replace('c', '')\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true\n              flagsPart.replace('g', '')\n            }\n            regexPart = regexPart + '/' + flagsPart\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */)\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart)\n            return\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression')\n          return\n        }\n        var state = getSearchState(cm)\n        var query = state.getQuery()\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line\n        var lineEnd = params.lineEnd || lineStart\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity\n        }\n        if (count) {\n          lineStart = lineEnd\n          lineEnd = lineStart + count - 1\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0))\n        var cursor = cm.getSearchCursor(query, startPos)\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback)\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function (cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm)\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save()\n        }\n      },\n      nohlsearch: function (cm) {\n        clearSearchHighlight(cm)\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor())\n        var line = cur.line\n        var lineText = cm.getLine(line)\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true)\n      },\n      delmarks: function (cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required')\n          return\n        }\n\n        var state = cm.state.vim\n        var stream = new CodeMirror.StringStream(trim(params.argString))\n        while (!stream.eol()) {\n          stream.eatSpace()\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count))\n            return\n          }\n\n          var sym = stream.next()\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count))\n              return\n            }\n\n            var startMark = sym\n            var finishMark = stream.next()\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0)\n              var finish = finishMark.charCodeAt(0)\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count))\n                return\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j)\n                delete state.marks[mark]\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-')\n              return\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym]\n          }\n        }\n      }\n    }\n\n    var exCommandDispatcher = new ExCommandDispatcher()\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace (cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true\n      var done = false\n      var lastPos = searchCursor.from()\n      function replaceAll () {\n        cm.operation(function () {\n          while (!done) {\n            replace()\n            next()\n          }\n          stop()\n        })\n      }\n      function replace () {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to())\n        var newText = text.replace(query, replaceWith)\n        searchCursor.replace(newText)\n      }\n      function next () {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while (searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue\n          }\n          cm.scrollIntoView(searchCursor.from(), 30)\n          cm.setSelection(searchCursor.from(), searchCursor.to())\n          lastPos = searchCursor.from()\n          done = false\n          return\n        }\n        done = true\n      }\n      function stop (close) {\n        if (close) { close() }\n        cm.focus()\n        if (lastPos) {\n          cm.setCursor(lastPos)\n          var vim = cm.state.vim\n          vim.exMode = false\n          vim.lastHPos = vim.lastHSPos = lastPos.ch\n        }\n        if (callback) { callback() }\n      }\n      function onPromptKeyDown (e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e)\n        var keyName = CodeMirror.keyName(e)\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break\n          case 'N':\n            next(); break\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback\n            callback = undefined\n            cm.operation(replaceAll)\n            callback = savedCallback\n            break\n          case 'L':\n            replace()\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close)\n            break\n        }\n        if (done) { stop(close) }\n        return true\n      }\n\n      // Actually do replace.\n      next()\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source)\n        return\n      }\n      if (!confirm) {\n        replaceAll()\n        if (callback) { callback() };\n        return\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      })\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      // call: cmKey\n    }\n\n    function exitInsertMode (cm) {\n      var vim = cm.state.vim\n      var macroModeState = vimGlobalState.macroModeState\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.')\n      var isPlaying = macroModeState.isPlaying\n      var lastChange = macroModeState.lastInsertModeChanges\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = []\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1\n        var changes = lastChange.changes\n        var text = []\n        var i = 0\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i])\n          if (changes[i] instanceof InsertModeKey) {\n            i++\n          } else {\n            i += selLength\n          }\n        }\n        lastChange.changes = text\n        cm.off('change', onChange)\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown)\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */)\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat\n      }\n      delete vim.insertModeRepeat\n      vim.insertMode = false\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1)\n      cm.setOption('keyMap', 'vim')\n      cm.setOption('disableInput', true)\n      cm.toggleOverwrite(false) // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''))\n      CodeMirror.signal(cm, 'vim-mode-change', {mode: 'normal'})\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState)\n      }\n    }\n\n    function _mapCommand (command) {\n      defaultKeymap.unshift(command)\n    }\n\n    function mapCommand (keys, type, name, args, extra) {\n      var command = {keys: keys, type: type}\n      command[type] = name\n      command[type + 'Args'] = args\n      for (var key in extra) { command[key] = extra[key] }\n      _mapCommand(command)\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number')\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      // fallthrough: ['default'],\n      fallthrough: [],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      // call: cmKey\n    }\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      // call: cmKey\n    }\n\n    function executeMacroRegister (cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName)\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0])\n        }\n        macroModeState.isPlaying = false\n        return\n      }\n      var keyBuffer = register.keyBuffer\n      var imc = 0\n      macroModeState.isPlaying = true\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0)\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i]\n        var match, key\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text)\n          key = match[0]\n          text = text.substring(match.index + key.length)\n          CodeMirror.Vim.handleKey(cm, key, 'macro')\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes\n            repeatInsertModeChanges(cm, changes, 1)\n            exitInsertMode(cm)\n          }\n        }\n      };\n      macroModeState.isPlaying = false\n    }\n\n    function logKey (macroModeState, key) {\n      if (macroModeState.isPlaying) { return }\n      var registerName = macroModeState.latestRegister\n      var register = vimGlobalState.registerController.getRegister(registerName)\n      if (register) {\n        register.pushText(key)\n      }\n    }\n\n    function logInsertModeChange (macroModeState) {\n      if (macroModeState.isPlaying) { return }\n      var registerName = macroModeState.latestRegister\n      var register = vimGlobalState.registerController.getRegister(registerName)\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges)\n      }\n    }\n\n    function logSearchQuery (macroModeState, query) {\n      if (macroModeState.isPlaying) { return }\n      var registerName = macroModeState.latestRegister\n      var register = vimGlobalState.registerController.getRegister(registerName)\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query)\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange (cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState\n      var lastChange = macroModeState.lastInsertModeChanges\n      if (!macroModeState.isPlaying) {\n        while (changeObj) {\n          lastChange.expectCursorActivityForChange = true\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste' ||\n              changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n')\n            if (lastChange.maybeReset) {\n              lastChange.changes = []\n              lastChange.maybeReset = false\n            }\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text])\n            } else {\n              lastChange.changes.push(text)\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity (cm) {\n      var vim = cm.state.vim\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState\n        if (macroModeState.isPlaying) { return }\n        var lastChange = macroModeState.lastInsertModeChanges\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim)\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm)\n      }\n    }\n    function updateFakeCursor (cm) {\n      var vim = cm.state.vim\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head))\n      var to = offsetCursor(from, 0, 1)\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear()\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'})\n    }\n    function handleExternalSelection (cm, vim) {\n      var anchor = cm.getCursor('anchor')\n      var head = cm.getCursor('head')\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false)\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true\n        vim.visualLine = false\n        CodeMirror.signal(cm, 'vim-mode-change', {mode: 'visual'})\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0\n        head = offsetCursor(head, 0, headOffset)\n        anchor = offsetCursor(anchor, 0, anchorOffset)\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        }\n        updateMark(cm, vim, '<', cursorMin(head, anchor))\n        updateMark(cm, vim, '>', cursorMax(head, anchor))\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey (keyName) {\n      this.keyName = keyName\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown (e) {\n      var macroModeState = vimGlobalState.macroModeState\n      var lastChange = macroModeState.lastInsertModeChanges\n      var keyName = CodeMirror.keyName(e)\n      if (!keyName) { return }\n      function onKeyFound () {\n        if (lastChange.maybeReset) {\n          lastChange.changes = []\n          lastChange.maybeReset = false\n        }\n        lastChange.changes.push(new InsertModeKey(keyName))\n        return true\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound)\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit (cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState\n      macroModeState.isPlaying = true\n      var isAction = !!vim.lastEditActionCommand\n      var cachedInputState = vim.inputState\n      function repeatCommand () {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand)\n        } else {\n          commandDispatcher.evalInput(cm, vim)\n        }\n      }\n      function repeatInsert (repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat\n          var changeObject = macroModeState.lastInsertModeChanges\n          repeatInsertModeChanges(cm, changeObject.changes, repeat)\n        }\n      }\n      vim.inputState = vim.lastEditInputState\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand()\n          repeatInsert(1)\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand()\n        }\n        repeatInsert(repeat)\n      }\n      vim.inputState = cachedInputState\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm)\n      }\n      macroModeState.isPlaying = false\n    };\n\n    function repeatInsertModeChanges (cm, changes, repeat) {\n      function keyHandler (binding) {\n        if (typeof binding === 'string') {\n          CodeMirror.commands[binding](cm)\n        } else {\n          binding(cm)\n        }\n        return true\n      }\n      var head = cm.getCursor('head')\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim\n        var lastSel = vim.lastSelection\n        var offset = getOffset(lastSel.anchor, lastSel.head)\n        selectForInsert(cm, head, offset.line + 1)\n        repeat = cm.listSelections().length\n        cm.setCursor(head)\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0))\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j]\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler)\n          } else if (typeof change === 'string') {\n            var cur = cm.getCursor()\n            cm.replaceRange(change, cur, cur)\n          } else {\n            var start = cm.getCursor()\n            var end = offsetCursor(start, 0, change[0].length)\n            cm.replaceRange(change[0], start, end)\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1))\n      }\n    }\n\n    resetVimGlobalState()\n\n    vimApi.commandDispatcher = commandDispatcher\n    vimApi.exCommandDispatcher = exCommandDispatcher\n    return vimApi\n  }\n\n  // Initialize Vim and make it available as an API.\n  return CodeMirror.Vim = Vim()\n}\n"]}